#!/usr/bin/env python3
"""
Microservice Factory - CLI Tool
Creates microservices with CQRS, Event-Driven Architecture support
"""

import os
import sys
import yaml
import click
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
from typing import Dict, Any, List
import json

class MicroserviceFactory:
    def __init__(self):
        self.templates_dir = Path(__file__).parent / "templates"
        self.output_dir = Path.cwd()
        
    def load_architect_config(self) -> Dict[str, Any]:
        """Load architect.yaml configuration"""
        config_path = self.output_dir / "architect.yaml"
        if not config_path.exists():
            raise click.ClickException("architect.yaml not found in current directory")
        
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
        
    def get_gateway_package_json(self) -> str:
        return '''{
  "name": "api-gateway",
  "version": "1.0.0",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "http-proxy-middleware": "^2.0.6",
    "jsonwebtoken": "^9.0.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1"
  }
}'''

    def get_gateway_app(self, services: Dict[str, Any]) -> str:
        routes = []
        for name, cfg in services.items():
            port = cfg.get('port', 3000)
            routes.append(f'''
app.use('/api/{name}', createProxyMiddleware({{
    target: 'http://{name}-service:{port}',
    changeOrigin: true,
    pathRewrite: {{ '^/api/{name}': '' }}
}}));
''')
        return f'''const express = require('express');
const cors = require('cors');
const {{ createProxyMiddleware }} = require('http-proxy-middleware');
require('dotenv').config();

const app = express();
app.use(cors());

{''.join(routes)}

app.listen(8080, () => {{
    console.log('API Gateway running on port 8080');
}});
'''     
    
    def get_gateway_auth(self) -> str:
        return '''const jwt = require('jsonwebtoken');

const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key';

exports.authenticate = (req, res, next) => {
    const token = req.headers['authorization'];
    if (!token) return res.status(401).json({ error: 'No token provided' });
    jwt.verify(token, JWT_SECRET, (err, decoded) => {
        if (err) return res.status(401).json({ error: 'Invalid token' });
        req.user = decoded;
        next();
    });
};
'''

    def get_docker_compose(self, services: Dict[str, Any]) -> str:
        service_blocks = []
        for name, cfg in services.items():
            language = cfg.get('language', 'nodejs')
            port = cfg.get('port', 3000)
            image = f"{name}-service"
            build_dir = f"./services/{name}-service"
            service_blocks.append(f'''
  {name}-service:
    build: {build_dir}
    ports:
      - "{port}:{port}"
    networks:
      - microservices-network
    depends_on:
      - kafka
      - mongodb
      - postgresql
''')
        return f'''version: "3.8"
services:
  api-gateway:
    build: ./api-gateway
    ports:
      - "8080:8080"
    networks:
      - microservices-network
    depends_on:
      - kafka
      - mongodb
      - postgresql
{''.join(service_blocks)}
  kafka:
    image: bitnami/kafka:latest
    ports:
      - "9092:9092"
    networks:
      - microservices-network
  mongodb:
    image: mongo:latest
    ports:
      - "27017:27017"
    networks:
      - microservices-network
  postgresql:
    image: postgres:latest
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    networks:
      - microservices-network

networks:
  microservices-network:
    driver: bridge
'''
    

    def get_readme(self, config: Dict[str, Any]) -> str:
        project_name = config.get('project_name', 'microfactory')
        version = config.get('version', '1.0.0')
        services = config.get('services', {})
        service_list = "\n".join([f"- **{name}** ({cfg.get('language', '')}, {cfg.get('database', '')})" for name, cfg in services.items()])
        return f'''# {project_name}

Version: {version}

## Microservices

{service_list}

## Quick Start

1. Build all services:
   ```
   python main.py generate
   ```
2. Start with Docker Compose:
   ```
   docker compose up --build
   ```

## Generated by Microservice Factory
'''

    def get_nodejs_model(self, entity_name: str, props: Dict[str, str], db_type: str) -> str:
        # MongoDB için Mongoose model şeması
        fields = []
        for prop_name, prop_type in props.items():
            js_type = self.get_js_type(prop_type)
            fields.append(f"    {prop_name}: {{ type: {js_type} }},")
        return f'''const mongoose = require('mongoose');

const {entity_name}Schema = new mongoose.Schema({{
{chr(10).join(fields)}
}}, {{ timestamps: true }});

module.exports = mongoose.model('{entity_name}', {entity_name}Schema);
'''

    def get_js_type(self, prop_type: str) -> str:
        type_map = {
            'string': 'String',
            'int': 'Number',
            'float': 'Number',
            'bool': 'Boolean',
            'datetime': 'Date',
            'hashed-string': 'String'
        }
        return type_map.get(prop_type, 'String')

    def get_nodejs_controller(self, entity_name: str, props: Dict[str, str]) -> str:
        return f'''const {entity_name} = require('../models/{entity_name.lower()}');

exports.getAll = async (req, res) => {{
    const items = await {entity_name}.find();
    res.json(items);
}};

exports.getById = async (req, res) => {{
    const item = await {entity_name}.findById(req.params.id);
    res.json(item);
}};

exports.create = async (req, res) => {{
    const item = new {entity_name}(req.body);
    await item.save();
    res.status(201).json(item);
}};

exports.update = async (req, res) => {{
    const item = await {entity_name}.findByIdAndUpdate(req.params.id, req.body, {{ new: true }});
    res.json(item);
}};

exports.delete = async (req, res) => {{
    await {entity_name}.findByIdAndDelete(req.params.id);
    res.status(204).send();
}};
'''

    def get_nodejs_routes(self, entity_name: str) -> str:
        return f'''const express = require('express');
const router = express.Router();
const controller = require('../controllers/{entity_name.lower()}Controller');

router.get('/', controller.getAll);
router.get('/:id', controller.getById);
router.post('/', controller.create);
router.put('/:id', controller.update);
router.delete('/:id', controller.delete);

module.exports = router;
'''

    def get_nodejs_app(self, name: str, entities: Dict[str, Any], db_type: str) -> str:
        imports = "\n".join([f"const {entity.lower()}Routes = require('./routes/{entity.lower()}Routes');" for entity in entities.keys()])
        uses = "\n".join([f"app.use('/api/{entity.lower()}', {entity.lower()}Routes);" for entity in entities.keys()])
        db_url = "mongodb://localhost:27017/" + name + "db" if db_type == "mongodb" else ""
        return f'''const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const cors = require('cors');
require('dotenv').config();

const app = express();
app.use(cors());
app.use(bodyParser.json());

{imports}

{uses}

mongoose.connect('{db_url}', {{
    useNewUrlParser: true,
    useUnifiedTopology: true
}}).then(() => {{
    console.log('MongoDB connected');
}}).catch(err => {{
    console.error('MongoDB connection error:', err);
}});

module.exports = app;
'''

    def get_nodejs_server(self) -> str:
        return '''const app = require('./app');

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
'''

    def get_nodejs_dockerfile(self) -> str:
        return '''FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
'''
    
    def generate_services(self, config: Dict[str, Any]):
        """Generate all microservices based on config"""
        services = config.get('services', {})
        
        for service_name, service_config in services.items():
            self.generate_service(service_name, service_config)
        
        # Generate API Gateway
        self.generate_api_gateway(config)
        
        # Generate Docker Compose
        self.generate_docker_compose(config)
        
        # Generate README
        self.generate_readme(config)
    
    def generate_service(self, name: str, config: Dict[str, Any]):
        """Generate a single microservice"""
        language = config.get('language', 'dotnet')
        architecture = config.get('architecture', 'cqrs')
        
        service_dir = self.output_dir / "services" / f"{name}-service"
        service_dir.mkdir(parents=True, exist_ok=True)
        
        if language == 'dotnet':
            self.generate_dotnet_service(name, config, service_dir)
        elif language == 'java':
            self.generate_java_service(name, config, service_dir)
        elif language == 'nodejs':
            self.generate_nodejs_service(name, config, service_dir)

    def get_java_repository(self, entity_name: str, namespace: str) -> str:
        return f'''package com.microservices.{namespace.replace('-', '')}.repository;

    import com.microservices.{namespace.replace('-', '')}.entity.{entity_name};
    import org.springframework.data.jpa.repository.JpaRepository;
    import java.util.UUID;

    public interface {entity_name}Repository extends JpaRepository<{entity_name}, UUID> {{
        // Custom query methods if needed
    }}
    '''

    def get_java_main_application(self, name: str) -> str:
        package_name = f"com.microservices.{name.replace('-', '')}"
        class_name = f"{name.title().replace('-', '')}Application"
        return f'''package {package_name};

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class {class_name} {{

    public static void main(String[] args) {{
        SpringApplication.run({class_name}.class, args);
    }}
}}
'''
    def get_java_dockerfile(self, name: str) -> str:
        return f'''FROM eclipse-temurin:21-jdk AS build
WORKDIR /app
COPY . .
RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:21-jre
WORKDIR /app
COPY --from=build /app/target/{name}-service-1.0.0.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
'''
    
    def get_nodejs_package_json(self, name: str, db_type: str) -> str:
        dependencies = {
            "express": "^4.18.2",
            "mongoose": "^8.0.0" if db_type == "mongodb" else "",
            "body-parser": "^1.20.2",
            "cors": "^2.8.5",
            "dotenv": "^16.3.1",
            "kafkajs": "^2.2.4"
        }
        # Remove empty dependencies
        deps = {k: v for k, v in dependencies.items() if v}
        deps_str = ",\n    ".join([f'"{k}": "{v}"' for k, v in deps.items()])
        return f'''{{
  "name": "{name}-service",
  "version": "1.0.0",
  "main": "src/server.js",
  "scripts": {{
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  }},
  "dependencies": {{
    {deps_str}
  }}
}}'''
    
    def generate_dotnet_service(self, name: str, config: Dict[str, Any], service_dir: Path):
        """Generate .NET Core microservice"""
        entities = config.get('entities', {})
        events = config.get('events', [])
        db_type = config.get('database', 'postgresql')
        
        # Create project structure
        dirs = [
            f"{name}.Api",
            f"{name}.Application/Commands",
            f"{name}.Application/Queries",
            f"{name}.Application/DTOs",
            f"{name}.Domain/Entities",
            f"{name}.Domain/Events",
            f"{name}.Infrastructure/Data",
            f"{name}.Infrastructure/Repositories"
        ]
        
        for dir_name in dirs:
            (service_dir / dir_name).mkdir(parents=True, exist_ok=True)
        
        # Generate .csproj files
        self.create_file(service_dir / f"{name}.Api" / f"{name}.Api.csproj", self.get_dotnet_api_csproj(name))
        self.create_file(service_dir / f"{name}.Application" / f"{name}.Application.csproj", self.get_dotnet_application_csproj(name))
        self.create_file(service_dir / f"{name}.Domain" / f"{name}.Domain.csproj", self.get_dotnet_domain_csproj(name))
        self.create_file(service_dir / f"{name}.Infrastructure" / f"{name}.Infrastructure.csproj", self.get_dotnet_infrastructure_csproj(name, db_type))
        
        # Generate entities
        for entity_name, entity_props in entities.items():
            self.create_file(
                service_dir / f"{name}.Domain/Entities" / f"{entity_name}.cs",
                self.get_dotnet_entity(entity_name, entity_props, name)
            )
            
            # Generate DTOs
            self.create_file(
                service_dir / f"{name}.Application/DTOs" / f"{entity_name}Dto.cs",
                self.get_dotnet_dto(entity_name, entity_props, name)
            )
            
            # Generate Commands & Queries
            self.create_file(
                service_dir / f"{name}.Application/Commands" / f"Create{entity_name}Command.cs",
                self.get_dotnet_create_command(entity_name, entity_props, name)
            )
            
            self.create_file(
                service_dir / f"{name}.Application/Queries" / f"Get{entity_name}Query.cs",
                self.get_dotnet_get_query(entity_name, name)
            )
            
            # Generate Repository
            self.create_file(
                service_dir / f"{name}.Infrastructure/Repositories" / f"{entity_name}Repository.cs",
                self.get_dotnet_repository(entity_name, name)
            )
        
        # Generate events
        for event_name in events:
            self.create_file(
                service_dir / f"{name}.Domain/Events" / f"{event_name}.cs",
                self.get_dotnet_event(event_name, name)
            )
        
        # Generate main files
        self.create_file(service_dir / f"{name}.Api/Program.cs", self.get_dotnet_program(name, db_type))
        self.create_file(service_dir / f"{name}.Api/appsettings.json", self.get_dotnet_appsettings(name, db_type))
        self.create_file(service_dir / f"{name}.Infrastructure/Data/AppDbContext.cs", self.get_dotnet_dbcontext(name, entities))
        self.create_file(service_dir / "Dockerfile", self.get_dotnet_dockerfile(name))
    
    def generate_java_service(self, name: str, config: Dict[str, Any], service_dir: Path):
        """Generate Spring Boot microservice"""
        entities = config.get('entities', {})
        events = config.get('events', [])
        db_type = config.get('database', 'postgresql')
        
        package_path = f"com/microservices/{name.replace('-', '')}"
        
        # Create project structure
        src_main = service_dir / "src/main/java" / package_path
        src_test = service_dir / "src/test/java" / package_path
        resources = service_dir / "src/main/resources"
        
        dirs = [
            f"{src_main}/entity",
            f"{src_main}/dto",
            f"{src_main}/command",
            f"{src_main}/query",
            f"{src_main}/repository",
            f"{src_main}/service",
            f"{src_main}/controller",
            f"{src_main}/event",
            f"{src_test}",
            f"{resources}"
        ]
        
        for dir_path in dirs:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
        
        # Generate build files
        self.create_file(service_dir / "pom.xml", self.get_java_pom(name, db_type))
        self.create_file(resources / "application.yml", self.get_java_application_yml(name, db_type))
        
        # Generate entities and related classes
        for entity_name, entity_props in entities.items():
            self.create_file(
                src_main / "entity" / f"{entity_name}.java",
                self.get_java_entity(entity_name, entity_props, name)
            )
            
            self.create_file(
                src_main / "dto" / f"{entity_name}Dto.java",
                self.get_java_dto(entity_name, entity_props, name)
            )
            
            self.create_file(
                src_main / "repository" / f"{entity_name}Repository.java",
                self.get_java_repository(entity_name, name)
            )
        
        # Generate main application
        self.create_file(
            src_main / f"{name.title().replace('-', '')}Application.java",
            self.get_java_main_application(name)
        )
        
        self.create_file(service_dir / "Dockerfile", self.get_java_dockerfile(name))
    
    def generate_nodejs_service(self, name: str, config: Dict[str, Any], service_dir: Path):
        """Generate Node.js Express microservice"""
        entities = config.get('entities', {})
        events = config.get('events', [])
        db_type = config.get('database', 'mongodb')
        
        # Create project structure
        dirs = ["src/models", "src/controllers", "src/services", "src/routes", "src/middleware", "src/events"]
        for dir_name in dirs:
            (service_dir / dir_name).mkdir(parents=True, exist_ok=True)
        
        # Generate package.json
        self.create_file(service_dir / "package.json", self.get_nodejs_package_json(name, db_type))
        
        # Generate entities/models
        for entity_name, entity_props in entities.items():
            self.create_file(
                service_dir / "src/models" / f"{entity_name.lower()}.js",
                self.get_nodejs_model(entity_name, entity_props, db_type)
            )
            
            self.create_file(
                service_dir / "src/controllers" / f"{entity_name.lower()}Controller.js",
                self.get_nodejs_controller(entity_name, entity_props)
            )
            
            self.create_file(
                service_dir / "src/routes" / f"{entity_name.lower()}Routes.js",
                self.get_nodejs_routes(entity_name)
            )
        
        # Generate main files
        self.create_file(service_dir / "src/app.js", self.get_nodejs_app(name, entities, db_type))
        self.create_file(service_dir / "src/server.js", self.get_nodejs_server())
        self.create_file(service_dir / "Dockerfile", self.get_nodejs_dockerfile())
    
    def generate_api_gateway(self, config: Dict[str, Any]):
        """Generate API Gateway with Node.js"""
        gateway_dir = self.output_dir / "api-gateway"
        gateway_dir.mkdir(exist_ok=True)
        
        services = config.get('services', {})
        
        self.create_file(gateway_dir / "package.json", self.get_gateway_package_json())
        self.create_file(gateway_dir / "src/app.js", self.get_gateway_app(services))
        self.create_file(gateway_dir / "src/auth.js", self.get_gateway_auth())
        self.create_file(gateway_dir / "Dockerfile", self.get_nodejs_dockerfile())
        
        (gateway_dir / "src").mkdir(exist_ok=True)
    
    def generate_docker_compose(self, config: Dict[str, Any]):
        """Generate Docker Compose for development"""
        services = config.get('services', {})
        self.create_file(self.output_dir / "docker-compose.yml", self.get_docker_compose(services))
    
    def generate_readme(self, config: Dict[str, Any]):
        """Generate README.md"""
        self.create_file(self.output_dir / "README.md", self.get_readme(config))
    
    def create_file(self, path: Path, content: str):
        """Create a file with given content"""
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    # Template methods for .NET
    def get_dotnet_api_csproj(self, name: str) -> str:
        return f'''<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="MediatR.Extensions.Microsoft.DependencyInjection" Version="11.1.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Confluent.Kafka" Version="2.3.0" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="../{name}.Application/{name}.Application.csproj" />
    <ProjectReference Include="../{name}.Infrastructure/{name}.Infrastructure.csproj" />
  </ItemGroup>
</Project>'''

    def get_dotnet_application_csproj(self, name: str) -> str:
        return f'''<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="AutoMapper" Version="12.0.1" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="../{name}.Domain/{name}.Domain.csproj" />
  </ItemGroup>
</Project>'''

    def get_dotnet_domain_csproj(self, name: str) -> str:
        return '''<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
</Project>'''

    def get_dotnet_infrastructure_csproj(self, name: str, db_type: str) -> str:
        db_package = "Npgsql.EntityFrameworkCore.PostgreSQL" if db_type == "postgresql" else "Microsoft.EntityFrameworkCore.SqlServer"
        return f'''<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="{db_package}" Version="9.0.0" />
    <PackageReference Include="Confluent.Kafka" Version="2.3.0" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="../{name}.Domain/{name}.Domain.csproj" />
  </ItemGroup>
</Project>'''

    def get_dotnet_entity(self, entity_name: str, props: Dict[str, str], namespace: str) -> str:
        properties = []
        for prop_name, prop_type in props.items():
            csharp_type = self.get_csharp_type(prop_type)
            if prop_name.lower() == 'password':
                properties.append(f"    public {csharp_type} {prop_name.title()} {{ get; set; }} = string.Empty;")
            else:
                properties.append(f"    public {csharp_type} {prop_name.title()} {{ get; set; }}")
        
        return f'''using System.ComponentModel.DataAnnotations;

namespace {namespace}.Domain.Entities;

public class {entity_name}
{{
    public Guid Id {{ get; set; }} = Guid.NewGuid();
    public DateTime CreatedAt {{ get; set; }} = DateTime.UtcNow;
    public DateTime UpdatedAt {{ get; set; }} = DateTime.UtcNow;
    
{chr(10).join(properties)}
}}'''

    def get_csharp_type(self, prop_type: str) -> str:
        type_map = {
            'string': 'string',
            'int': 'int',
            'float': 'double',
            'bool': 'bool',
            'datetime': 'DateTime',
            'hashed-string': 'string'
        }
        return type_map.get(prop_type, 'string')

    def get_dotnet_dto(self, entity_name: str, props: Dict[str, str], namespace: str) -> str:
        properties = []
        for prop_name, prop_type in props.items():
            if prop_name.lower() != 'password':  # Exclude password from DTOs
                csharp_type = self.get_csharp_type(prop_type)
                properties.append(f"    public {csharp_type} {prop_name.title()} {{ get; set; }}")
        
        return f'''namespace {namespace}.Application.DTOs;

public class {entity_name}Dto
{{
    public Guid Id {{ get; set; }}
    public DateTime CreatedAt {{ get; set; }}
    public DateTime UpdatedAt {{ get; set; }}
    
{chr(10).join(properties)}
}}'''

    def get_dotnet_create_command(self, entity_name: str, props: Dict[str, str], namespace: str) -> str:
        return f'''using MediatR;
using {namespace}.Application.DTOs;

namespace {namespace}.Application.Commands;

public record Create{entity_name}Command : IRequest<{entity_name}Dto>
{{
    // Add command properties here based on entity
}}'''

    def get_dotnet_get_query(self, entity_name: str, namespace: str) -> str:
        return f'''using MediatR;
using {namespace}.Application.DTOs;

namespace {namespace}.Application.Queries;

public record Get{entity_name}Query(Guid Id) : IRequest<{entity_name}Dto?>;'''

    def get_dotnet_repository(self, entity_name: str, namespace: str) -> str:
        return f'''using {namespace}.Domain.Entities;
using {namespace}.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;

namespace {namespace}.Infrastructure.Repositories;

public interface I{entity_name}Repository
{{
    Task<{entity_name}?> GetByIdAsync(Guid id);
    Task<IEnumerable<{entity_name}>> GetAllAsync();
    Task<{entity_name}> AddAsync({entity_name} entity);
    Task UpdateAsync({entity_name} entity);
    Task DeleteAsync(Guid id);
}}

public class {entity_name}Repository : I{entity_name}Repository
{{
    private readonly AppDbContext _context;
    
    public {entity_name}Repository(AppDbContext context)
    {{
        _context = context;
    }}
    
    public async Task<{entity_name}?> GetByIdAsync(Guid id)
    {{
        return await _context.Set<{entity_name}>().FindAsync(id);
    }}
    
    public async Task<IEnumerable<{entity_name}>> GetAllAsync()
    {{
        return await _context.Set<{entity_name}>().ToListAsync();
    }}
    
    public async Task<{entity_name}> AddAsync({entity_name} entity)
    {{
        _context.Set<{entity_name}>().Add(entity);
        await _context.SaveChangesAsync();
        return entity;
    }}
    
    public async Task UpdateAsync({entity_name} entity)
    {{
        entity.UpdatedAt = DateTime.UtcNow;
        _context.Set<{entity_name}>().Update(entity);
        await _context.SaveChangesAsync();
    }}
    
    public async Task DeleteAsync(Guid id)
    {{
        var entity = await GetByIdAsync(id);
        if (entity != null)
        {{
            _context.Set<{entity_name}>().Remove(entity);
            await _context.SaveChangesAsync();
        }}
    }}
}}'''

    def get_dotnet_event(self, event_name: str, namespace: str) -> str:
        return f'''namespace {namespace}.Domain.Events;

public record {event_name}
{{
    public Guid Id {{ get; init; }} = Guid.NewGuid();
    public DateTime OccurredAt {{ get; init; }} = DateTime.UtcNow;
    // Add event-specific properties here
}}'''

    def get_dotnet_program(self, name: str, db_type: str) -> str:
        connection_string = "DefaultConnection" if db_type == "postgresql" else "DefaultConnection"
        db_context_method = "UseNpgsql" if db_type == "postgresql" else "UseSqlServer"
        
        return f'''using Microsoft.EntityFrameworkCore;
using {name}.Infrastructure.Data;
using MediatR;
using System.Reflection;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add MediatR
builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));

// Add DbContext
builder.Services.AddDbContext<AppDbContext>(options =>
    options.{db_context_method}(builder.Configuration.GetConnectionString("{connection_string}")));

var app = builder.Build();

// Configure pipeline
if (app.Environment.IsDevelopment())
{{
    app.UseSwagger();
    app.UseSwaggerUI();
}}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();'''

    def get_dotnet_appsettings(self, name: str, db_type: str) -> str:
        if db_type == "postgresql":
            conn_string = f"Host=localhost;Database={name}db;Username=postgres;Password=password"
        else:
            conn_string = f"Server=localhost;Database={name}db;Trusted_Connection=true;"
            
        return f'''{{
  "ConnectionStrings": {{
    "DefaultConnection": "{conn_string}"
  }},
  "Logging": {{
    "LogLevel": {{
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }}
  }},
  "AllowedHosts": "*"
}}'''

    def get_dotnet_dbcontext(self, name: str, entities: Dict[str, Any]) -> str:
        dbsets = []
        for entity_name in entities.keys():
            dbsets.append(f"    public DbSet<{entity_name}> {entity_name}s {{ get; set; }}")
        
        return f'''using Microsoft.EntityFrameworkCore;
using {name}.Domain.Entities;

namespace {name}.Infrastructure.Data;

public class AppDbContext : DbContext
{{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) {{ }}
    
{chr(10).join(dbsets)}
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {{
        base.OnModelCreating(modelBuilder);
        
        // Configure entities here
    }}
}}'''

    def get_dotnet_dockerfile(self, name: str) -> str:
        return f'''FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY . .
RUN dotnet restore "{name}.Api/{name}.Api.csproj"
RUN dotnet build "{name}.Api/{name}.Api.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "{name}.Api/{name}.Api.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "{name}.Api.dll"]'''

    # Java Spring Boot templates
    def get_java_pom(self, name: str, db_type: str) -> str:
        db_dependency = '''
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>''' if db_type == "postgresql" else '''
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>'''
        
        return f'''<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.microservices</groupId>
    <artifactId>{name}-service</artifactId>
    <version>1.0.0</version>
    <name>{name}-service</name>
    
    <properties>
        <java.version>21</java.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        {db_dependency}
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>'''

    def get_java_application_yml(self, name: str, db_type: str) -> str:
        if db_type == "postgresql":
            db_config = f'''
  datasource:
    url: jdbc:postgresql://localhost:5432/{name}db
    username: postgres
    password: password
    driver-class-name: org.postgresql.Driver'''
        else:
            db_config = '''
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:'''
        
        return f'''server:
  port: 8080

spring:
  application:
    name: {name}-service{db_config}
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      group-id: {name}-group
      auto-offset-reset: earliest
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer'''

    def get_java_entity(self, entity_name: str, props: Dict[str, str], namespace: str) -> str:
        properties = []
        for prop_name, prop_type in props.items():
            java_type = self.get_java_type(prop_type)
            properties.append(f"    private {java_type} {prop_name};")
        
        return f'''package com.microservices.{namespace.replace('-', '')}.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "{entity_name.lower()}s")
public class {entity_name} {{
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt = LocalDateTime.now();
    
{chr(10).join(properties)}
    
    // Constructors
    public {entity_name}() {{}}
    
    // Getters and Setters
    public UUID getId() {{ return id; }}
    public void setId(UUID id) {{ this.id = id; }}
    
    public LocalDateTime getCreatedAt() {{ return createdAt; }}
    public void setCreatedAt(LocalDateTime createdAt) {{ this.createdAt = createdAt; }}
    
    public LocalDateTime getUpdatedAt() {{ return updatedAt; }}
    public void setUpdatedAt(LocalDateTime updatedAt) {{ this.updatedAt = updatedAt; }}
    
    // Add getters and setters for other properties
}}'''

    def get_java_type(self, prop_type: str) -> str:
        type_map = {
            'string': 'String',
            'int': 'Integer',
            'float': 'Double',
            'bool': 'Boolean',
            'datetime': 'LocalDateTime',
            'hashed-string': 'String'
        }
        return type_map.get(prop_type, 'String')

    def get_java_dto(self, entity_name: str, props: Dict[str, str], namespace: str) -> str:
        return f'''package com.microservices.{namespace.replace('-', '')}.dto;

import java.time.LocalDateTime;
import java.util.UUID;

public class {entity_name}Dto {{
    private UUID id;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // Add DTO properties here
    
    // Constructors, getters and setters
    public {entity_name}Dto() {{}}
    
    public UUID getId() {{ return id; }}
    public void setId(UUID id) {{ this.id = id; }}
    
    public LocalDateTime getCreatedAt() {{ return createdAt; }}
    public void setCreatedAt(LocalDateTime createdAt) {{ this.createdAt = createdAt; }}
    
    public LocalDateTime getUpdatedAt() {{ return updatedAt; }}
    public void setUpdatedAt(LocalDateTime updatedAt) {{ this.updatedAt = updatedAt; }}
    
    // Add getters and setters for other properties
}}'''

@click.group()
def cli():
    """Microservice Factory CLI"""
    pass

@cli.command()
def generate():
    """Generate microservices from architect.yaml"""
    factory = MicroserviceFactory()
    try:
        config = factory.load_architect_config()
        factory.generate_services(config)
        click.secho("✅ Microservices generated successfully!", fg="green")
    except Exception as e:
        click.secho(f"❌ Error: {e}", fg="red")

@cli.command()
def info():
    """Show project info from architect.yaml"""
    factory = MicroserviceFactory()
    try:
        config = factory.load_architect_config()
        click.echo(json.dumps(config, indent=2, ensure_ascii=False))
    except Exception as e:
        click.secho(f"❌ Error: {e}", fg="red")

if __name__ == "__main__":
    cli()